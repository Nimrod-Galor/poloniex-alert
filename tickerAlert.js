var cp = {"7":"BTC_BCN","8":"BTC_BELA","10":"BTC_BLK","12":"BTC_BTCD","13":"BTC_BTM","14":"BTC_BTS","15":"BTC_BURST","20":"BTC_CLAM","25":"BTC_DGB","27":"BTC_DOGE","24":"BTC_DASH","28":"BTC_EMC2","31":"BTC_FLDC","32":"BTC_FLO","38":"BTC_GAME","40":"BTC_GRC","43":"BTC_HUC","50":"BTC_LTC","51":"BTC_MAID","58":"BTC_OMNI","61":"BTC_NAV","63":"BTC_NEOS","64":"BTC_NMC","69":"BTC_NXT","73":"BTC_PINK","74":"BTC_POT","75":"BTC_PPC","83":"BTC_RIC","89":"BTC_STR","92":"BTC_SYS","97":"BTC_VIA","98":"BTC_XVC","99":"BTC_VRC","100":"BTC_VTC","104":"BTC_XBC","108":"BTC_XCP","112":"BTC_XEM","114":"BTC_XMR","116":"BTC_XPM","117":"BTC_XRP","121":"USDT_BTC","122":"USDT_DASH","123":"USDT_LTC","124":"USDT_NXT","125":"USDT_STR","126":"USDT_XMR","127":"USDT_XRP","129":"XMR_BCN","130":"XMR_BLK","131":"XMR_BTCD","132":"XMR_DASH","137":"XMR_LTC","138":"XMR_MAID","140":"XMR_NXT","148":"BTC_ETH","149":"USDT_ETH","150":"BTC_SC","151":"BTC_BCY","153":"BTC_EXP","155":"BTC_FCT","158":"BTC_RADS","160":"BTC_AMP","162":"BTC_DCR","163":"BTC_LSK","166":"ETH_LSK","167":"BTC_LBC","168":"BTC_STEEM","169":"ETH_STEEM","170":"BTC_SBD","171":"BTC_ETC","172":"ETH_ETC","173":"USDT_ETC","174":"BTC_REP","175":"USDT_REP","176":"ETH_REP","177":"BTC_ARDR","178":"BTC_ZEC","179":"ETH_ZEC","180":"USDT_ZEC","181":"XMR_ZEC","182":"BTC_STRAT","183":"BTC_NXC","184":"BTC_PASC","185":"BTC_GNT","186":"ETH_GNT","187":"BTC_GNO","188":"ETH_GNO","189":"BTC_BCH","190":"ETH_BCH","191":"USDT_BCH","192":"BTC_ZRX","193":"ETH_ZRX","194":"BTC_CVC","195":"ETH_CVC","196":"BTC_OMG","197":"ETH_OMG","198":"BTC_GAS","199":"ETH_GAS","200":"BTC_STORJ"};
var currencyNamesArray = {"1CR":"1CRedit","ABY":"ArtByte","AC":"AsiaCoin","ACH":"Altcoin Herald","ADN":"Aiden","AEON":"AEON Coin","AERO":"Aerocoin","AIR":"AIRcoin","APH":"AphroditeCoin","AUR":"Auroracoin","AXIS":"Axis","BALLS":"Snowballs","BANK":"BankCoin","BBL":"BitBlock","BBR":"Boolberry","BCC":"BTCtalkcoin","BCN":"Bytecoin","BDC":"Black Dragon Coin","BDG":"Badgercoin","BELA":"Bela","BITS":"Bitstar","BLK":"BlackCoin","BLOCK":"Blocknet","BLU":"BlueCoin","BNS":"BonusCoin","BONES":"Bones","BOST":"BoostCoin","BTC":"Bitcoin","BTCD":"BitcoinDark","BTCS":"Bitcoin-sCrypt","BTM":"Bitmark","BTS":"BitShares","BURN":"BurnerCoin","BURST":"Burst","C2":"Coin2.0","CACH":"CACHeCoin","CAI":"CaiShen","CC":"Colbert Coin","CCN":"Cannacoin","CGA":"Cryptographic Anomaly","CHA":"Chancecoin","CINNI":"CinniCoin","CLAM":"CLAMS","CNL":"ConcealCoin","CNMT":"Coinomat1","CNOTE":"C-Note","COMM":"CommunityCoin","CON":"Coino","CORG":"CorgiCoin","CRYPT":"CryptCoin","CURE":"Curecoin","CYC":"Conspiracy Coin","DGB":"DigiByte","DICE":"NeoDICE","DIEM":"Diem","DIME":"Dimecoin","DIS":"DistroCoin","DNS":"BitShares DNS","DOGE":"Dogecoin","DASH":"Dash","DRKC":"DarkCash","DRM":"Dreamcoin","DSH":"Dashcoin","DVK":"DvoraKoin","EAC":"EarthCoin","EBT":"EBTcoin","ECC":"ECCoin","EFL":"Electronic Gulden","EMC2":"Einsteinium","EMO":"EmotiCoin","ENC":"Entropycoin","eTOK":"eToken","EXE":"Execoin","FAC":"Faircoin","FCN":"Fantomcoin","FIBRE":"Fibrecoin","FLAP":"FlappyCoin","FLDC":"FoldingCoin","FLT":"FlutterCoin","FOX":"FoxCoin","FRAC":"Fractalcoin","FRK":"Franko","FRQ":"FairQuark","FVZ":"FVZCoin","FZ":"Frozen","FZN":"Fuzon","GAP":"Gapcoin","GDN":"Global Denomination","GEMZ":"GetGems","GEO":"GeoCoin","GIAR":"Giarcoin","GLB":"Globe","GAME":"GameCredits","GML":"GameleagueCoin","GNS":"GenesisCoin","GOLD":"GoldEagles","GPC":"GROUPCoin","GPUC":"GPU Coin","GRCX":"Gridcoin","GRS":"Groestlcoin","GUE":"Guerillacoin","H2O":"H2O Coin","HIRO":"Hirocoin","HOT":"Hotcoin","HUC":"Huntercoin","HVC":"Heavycoin","HYP":"HyperStake","HZ":"Horizon","IFC":"Infinitecoin","ITC":"Information Coin","IXC":"iXcoin","JLH":"jl777hodl","JPC":"JackpotCoin","JUG":"JuggaloCoin","KDC":"KlondikeCoin","KEY":"KeyCoin","LC":"Limecoin","LCL":"Limecoin Lite","LEAF":"Leafcoin","LGC":"Logicoin","LOL":"LeagueCoin","LOVE":"LOVEcoin","LQD":"LIQUID","LTBC":"LTBCoin","LTC":"Litecoin","LTCX":"LiteCoinX","MAID":"MaidSafeCoin","MAST":"MastiffCoin","MAX":"MaxCoin","MCN":"Moneta Verde","MEC":"Megacoin","METH":"CryptoMETH","MIL":"Millennium Coin","MIN":"Minerals","MINT":"Mintcoin","MMC":"MemoryCoin","MMNXT":"MMNXT","MMXIV":"Maieuticoin","MNTA":"Moneta","MON":"Monocle","MRC":"microCoin","MRS":"Marscoin","OMNI":"Omni","MTS":"Metiscoin","MUN":"Muniti","MYR":"Myriadcoin","MZC":"MazaCoin","N5X":"N5coin","NAS":"NAS","NAUT":"Nautiluscoin","NAV":"NAVCoin","NBT":"NuBits","NEOS":"Neoscoin","NL":"Nanolite","NMC":"Namecoin","NOBL":"NobleCoin","NOTE":"DNotes","NOXT":"NobleNXT","NRS":"NoirShares","NSR":"NuShares","NTX":"NTX","NXT":"NXT","NXTI":"NXTInspect","OPAL":"Opal","PAND":"PandaCoin","PAWN":"Pawncoin","PIGGY":"New Piggycoin","PINK":"Pinkcoin","PLX":"ParallaxCoin","PMC":"Premine","POT":"PotCoin","PPC":"Peercoin","PRC":"ProsperCoin","PRT":"Particle","PTS":"BitShares PTS","Q2C":"QubitCoin","QBK":"Qibuck","QCN":"QuazarCoin","QORA":"Qora","QTL":"Quatloo","RBY":"Rubycoin","RDD":"Reddcoin","RIC":"Riecoin","RZR":"Razor","SDC":"Shadow","SHIBE":"ShibeCoin","SHOPX":"ShopX","SILK":"Silkcoin","SJCX":"Storjcoin X","SLR":"SolarCoin","SMC":"SmartCoin","SOC":"SocialCoin","SPA":"Spaincoin","SQL":"Squallcoin","SRCC":"SourceCoin","SRG":"Surge","SSD":"Sonic","STR":"Stellar","SUM":"SummerCoin","SUN":"Suncoin","SWARM":"SWARM","SXC":"Sexcoin","SYNC":"Sync","SYS":"Syscoin","TAC":"Talkcoin","TOR":"TorCoin","TRUST":"TrustPlus","TWE":"Twecoin","UIS":"Unitus","ULTC":"Umbrella-LTC","UNITY":"SuperNET","URO":"Uro","USDE":"USDE","USDT":"Tether USD","UTC":"UltraCoin","UTIL":"UtilityCoin","UVC":"UniversityCoin","VIA":"Viacoin","VOOT":"VootCoin","VRC":"VeriCoin","VTC":"Vertcoin","WC":"WhiteCoin","WDC":"Worldcoin","WIKI":"Wikicoin","WOLF":"InsanityCoin","X13":"X13Coin","XAI":"Sapience AIFX","XAP":"API Coin","XBC":"BitcoinPlus","XC":"XCurrency","XCH":"ClearingHouse","XCN":"Cryptonite","XCP":"Counterparty","XCR":"Crypti","XDN":"DigitalNote","XDP":"Dogeparty","XHC":"Honorcoin","XLB":"Libertycoin","XMG":"Magi","XMR":"Monero","XPB":"Pebblecoin","XPM":"Primecoin","XRP":"Ripple","XSI":"Stability Shares","XST":"StealthCoin","XSV":"Silicon Valley Coin","XUSD":"CoinoUSD","XXC":"CREDS","YACC":"YACCoin","YANG":"Yangcoin","YC":"YellowCoin","YIN":"Yincoin","XVC":"Vcash","FLO":"Florincoin","XEM":"NEM","ARCH":"ARCHcoin","HUGE":"BIGcoin","GRC":"Gridcoin Research","IOC":"IO Digital Currency","INDEX":"CoinoIndex","ETH":"Ethereum","SC":"Siacoin","BCY":"BitCrystals","EXP":"Expanse","FCT":"Factom","BITUSD":"BitUSD","BITCNY":"BitCNY","RADS":"Radium","AMP":"Synereo AMP","VOX":"Voxels","DCR":"Decred","LSK":"Lisk","DAO":"The DAO","LBC":"LBRY Credits","STEEM":"STEEM","SBD":"Steem Dollars","ETC":"Ethereum Classic","REP":"Augur","ARDR":"Ardor","ZEC":"Zcash","STRAT":"Stratis","NXC":"Nexium","PASC":"PascalCoin","GNT":"Golem","GNO":"Gnosis","BCH":"Bitcoin Cash","ZRX":"0x","CVC":"Civic","OMG":"OmiseGO","GAS":"Gas","STORJ":"Storj","MNS1":"Mining Shares"};
var tickerAPI_url = 'https://poloniex.com/public?command=returnTicker';
//localStorage.removeItem("userSettings");
var userSettings = localStorage.userSettings ? JSON.parse(localStorage.getItem("userSettings")) : {smaPeriod:50, emaPeriod:30, ema2Period:20, showSma: false, showEma: true, showFib: false, bollingerBand: true, showEma2: true, showHide:false, muteAlert:false, showMarkets:[], marketAlerts:{BTC_AMP:{volume:0, bollinger:true},BTC_ARDR:{volume:0, bollinger:true},BTC_BCH:{volume:0, bollinger:true},BTC_BCN:{volume:0, bollinger:true},BTC_BCY:{volume:0, bollinger:true},BTC_BELA:{volume:0, bollinger:true},BTC_BLK:{volume:0, bollinger:true},BTC_BTCD:{volume:0, bollinger:true},BTC_BTM:{volume:0, bollinger:true},BTC_BTS:{volume:0, bollinger:true},BTC_BURST:{volume:0, bollinger:true},BTC_CLAM:{volume:0, bollinger:true},BTC_CVC:{volume:0, bollinger:true},BTC_DASH:{volume:0, bollinger:true},BTC_DCR:{volume:0, bollinger:true},BTC_DGB:{volume:0, bollinger:true},BTC_DOGE:{volume:0, bollinger:true},BTC_EMC2:{volume:0, bollinger:true},BTC_ETC:{volume:0, bollinger:true},BTC_ETH:{volume:0, bollinger:true},BTC_EXP:{volume:0, bollinger:true},BTC_FCT:{volume:0, bollinger:true},BTC_FLDC:{volume:0, bollinger:true},BTC_FLO:{volume:0, bollinger:true},BTC_GAME:{volume:0, bollinger:true},BTC_GAS:{volume:0, bollinger:true},BTC_GNO:{volume:0, bollinger:true},BTC_GNT:{volume:0, bollinger:true},BTC_GRC:{volume:0, bollinger:true},BTC_HUC:{volume:0, bollinger:true},BTC_LBC:{volume:0, bollinger:true},BTC_LSK:{volume:0, bollinger:true},BTC_LTC:{volume:0, bollinger:true},BTC_MAID:{volume:0, bollinger:true},BTC_NAV:{volume:0, bollinger:true},BTC_NEOS:{volume:0, bollinger:true},BTC_NMC:{volume:0, bollinger:true},BTC_NXC:{volume:0, bollinger:true},BTC_NXT:{volume:0, bollinger:true},BTC_OMG:{volume:0, bollinger:true},BTC_OMNI:{volume:0, bollinger:true},BTC_PASC:{volume:0, bollinger:true},BTC_PINK:{volume:0, bollinger:true},BTC_POT:{volume:0, bollinger:true},BTC_PPC:{volume:0, bollinger:true},BTC_RADS:{volume:0, bollinger:true},BTC_REP:{volume:0, bollinger:true},BTC_RIC:{volume:0, bollinger:true},BTC_SBD:{volume:0, bollinger:true},BTC_SC:{volume:0, bollinger:true},BTC_STEEM:{volume:0, bollinger:true},BTC_STORJ:{volume:0, bollinger:true},BTC_STR:{volume:0, bollinger:true},BTC_STRAT:{volume:0, bollinger:true},BTC_SYS:{volume:0, bollinger:true},BTC_VIA:{volume:0, bollinger:true},BTC_VRC:{volume:0, bollinger:true},BTC_VTC:{volume:0, bollinger:true},BTC_XBC:{volume:0, bollinger:true},BTC_XCP:{volume:0, bollinger:true},BTC_XEM:{volume:0, bollinger:true},BTC_XMR:{volume:0, bollinger:true},BTC_XPM:{volume:0, bollinger:true},BTC_XRP:{volume:0, bollinger:true},BTC_XVC:{volume:0, bollinger:true},BTC_ZEC:{volume:0, bollinger:true},BTC_ZRX:{volume:0, bollinger:true},ETH_BCH:{volume:0, bollinger:true},ETH_CVC:{volume:0, bollinger:true},ETH_ETC:{volume:0, bollinger:true},ETH_GAS:{volume:0, bollinger:true},ETH_GNO:{volume:0, bollinger:true},ETH_GNT:{volume:0, bollinger:true},ETH_LSK:{volume:0, bollinger:true},ETH_OMG:{volume:0, bollinger:true},ETH_REP:{volume:0, bollinger:true},ETH_STEEM:{volume:0, bollinger:true},ETH_ZEC:{volume:0, bollinger:true},ETH_ZRX:{volume:0, bollinger:true},USDT_BCH:{volume:0, bollinger:true},USDT_BTC:{volume:0, bollinger:true},USDT_DASH:{volume:0, bollinger:true},USDT_ETC:{volume:0, bollinger:true},USDT_ETH:{volume:0, bollinger:true},USDT_LTC:{volume:0, bollinger:true},USDT_NXT:{volume:0, bollinger:true},USDT_REP:{volume:0, bollinger:true},USDT_STR:{volume:0, bollinger:true},USDT_XMR:{volume:0, bollinger:true},USDT_XRP:{volume:0, bollinger:true},USDT_ZEC:{volume:0, bollinger:true},XMR_BCN:{volume:0, bollinger:true},XMR_BLK:{volume:0, bollinger:true},XMR_BTCD:{volume:0, bollinger:true},XMR_DASH:{volume:0, bollinger:true},XMR_LTC:{volume:0, bollinger:true},XMR_MAID:{volume:0, bollinger:true},XMR_NXT:{volume:0, bollinger:true},XMR_ZEC:{volume:0, bollinger:true}}};
var marketSubscription = [];
var chartStartDate, chartEndDate;
var chartType = 300;//valid values are 300, 900, 1800, 7200, 14400, and 86400
var allChartData = {};
var lastTickerData = [];
var weightedAverageArr = {};
var userFib = {canvasId:null, startX:null, startY:null, endX:null, endY:null, mouse:null};
var chartImgData = null;
var chartRange = 86400;// 24 hours
var smaPeriod = 50;
var emaPeriod = 30;
var ema2Period =20;
var showSma = true;
var showEma = true;
var showFib = false;
var bollingerBand = false;
var showEma2 = false;
var dark = false;
var chartLeftPercent = 0.0;
var catchVolAlert = true;
var catchBolAlert = true;
var audio1 = new Audio('beep-07.mp3');
var audio2 = new Audio('beep-08.mp3');

function initWebSockets(){
	console.log("init WebSockets");
	window.connection = new WebSocket('wss://api2.poloniex.com');
	
	window.connection.onopen = function (session) {
		window.connection.send(JSON.stringify({command: "subscribe",channel: 1002}));
		//1000 - balance
	    //1001 - trollboxEvent
	    //1002 - ticker
	    //1003 - serverTime
		//1010 - Heartbeat
		//2000 - cancelOrder/Alert
		initAllChars();
	}
	
	window.connection.onmessage = function(e){
		if (e.data.length == 0) { return; }

		var msg = JSON.parse(e.data);
//console.log(msg);
		if(msg.length < 3) { return; }
		switch (msg[0]){
		    case 1002://Ticker
				msg[2][0] = cp[msg[2][0]]; // currency pair id to text
				tickerEvent(msg[2]);
			break;
			case 1010:
		    	// Heartbeat
		    break;
			default:// Order Booke
				//console.log(msg);
				orderBookEvent(msg);
			break;
		}
	}
	
	window.connection.onclose = function () {
	  console.log("Websocket connection closed");
	}
}

function getTickerInfo(){
	$.getJSON(tickerAPI_url, function(d) {
		for (pair in d){
			var row = $("#marketRow" + pair);
			row.find('.price').html(d[pair]['last']);
			row.find('.lowestAsk').html(d[pair]['lowestAsk']);
			row.find('.highestBid').html(d[pair]['highestBid']);
			row.find('.change').html(exactRound(d[pair]['percentChange'] * 100,2));
			if(d[pair]['percentChange'] < 0){ row.find('.change').addClass('neg'); }else{ row.find('.change').removeClass('neg');}
			row.find('.volume').html(parseFloat(d[pair]['baseVolume']).toFixed(0));
			//row.find('.price').html(d[pair]['quoteVolume']);
			//row.find('.isFrozen').html(d[pair]['isFrozen']);
			row.find('.high24hr').html(d[pair]['high24hr']);
			row.find('.low24hr').html(d[pair]['low24hr']);

			lastTickerData[pair] = {
				last: d[pair]['last'],
				lowestAsk: d[pair]['lowestAsk'],
				highestBid: d[pair]['highestBid'],
				percentChange: d[pair]['percentChange'],
				baseVolume: d[pair]['baseVolume'],
				quoteVolume: d[pair]['quoteVolume'],
				//isFrozen: d[pair]['isFrozen'],
				high24hr: d[pair]['high24hr'],
				low24hr: d[pair]['low24hr']
			};
		}
		initWebSockets();
	});
}

function orderBookEvent(msg){
	let needUpdate = false;
	let pair = cp[msg[0]];
	for (var i in msg[2]){
		var arg = msg[2][i];
		switch (arg[0]){
			case "t":// newTrade
				/*if(!(pair in allChartData)){// check that we initiated this chart type
					return;
				}*/

				needUpdate = true;
				let rate = parseFloat(arg[3]);
				let amount = parseFloat(arg[4]);
				let candleDate = parseInt(allChartData[pair]['candleStick'][allChartData[pair]['candleStick'].length-1]['date']) + parseInt(chartType);
				// check if new candle
				if(candleDate < parseInt(arg[5])){// new candle
					catchVolAlert = true;
					catchBolAlert = true;
					weightedAverageArr[pair] = [{amount:amount,price:rate}];
					let quoteVolume = amount / rate;
					allChartData[pair]['candleStick'].push({close:rate,date:candleDate,high:rate,low:rate,open:rate,quoteVolume:quoteVolume,volume:amount * rate,weightedAverage:rate});
					allChartData[pair]['candleStick'].shift(); // Removes the first element
				}else{// update current candle
					weightedAverageArr[pair].push({amount:amount,price:rate});
					let lastItem = allChartData[pair]['candleStick'].length-1;
					allChartData[pair]['candleStick'][lastItem]['weightedAverage'] = calacWeightedAverage(weightedAverageArr[pair]);
					allChartData[pair]['candleStick'][lastItem]['volume'] += amount * rate;
					allChartData[pair]['candleStick'][lastItem]['close'] = rate;
					if(allChartData[pair]['candleStick'][lastItem]['high'] < rate){
						allChartData[pair]['candleStick'][lastItem]['high'] = rate;
					}
					if(allChartData[pair]['candleStick'][lastItem]['low'] > rate){
						allChartData[pair]['candleStick'][lastItem]['low'] = rate;
					}
				}
				// check volume alert
				if(catchVolAlert && userSettings.marketAlerts[pair].volume > 0 && allChartData[pair]['candleStick'][allChartData[pair]['candleStick'].length-1]['volume'] >= userSettings.marketAlerts[pair].volume){
					catchVolAlert = false;
					printAlert('<a href="#' + pair + 'Chart">' + pair + "</a> - volume: " + allChartData[pair]['candleStick'][allChartData[pair]['candleStick'].length-1]['volume'].toFixed(10));
					if(!userSettings.muteAlert){
						audio1.play();
					}
				}
			break;
		}
	}
	if(needUpdate){
		chartEndDate = parseInt(allChartData[pair]['candleStick'][allChartData[pair]['candleStick'].length-1]['date']);//Math.floor(new Date().getTime() / 1000);
		chartStartDate = chartEndDate - chartRange;
		refreshChart(pair);
	}
}

function calacWeightedAverage(arr){
	let sum = 0;
	let shareNum = 0;
	for(let x=0;x<arr.length;x++){
		sum += arr[x].amount * arr[x].price;
		shareNum += arr[x].amount;
	}
	//return parseFloat(sum / shareNum).toFixed(8);
	return (sum / shareNum);
}

function tickerEvent(args, kwargs) {
	if(!userSettings.showHide || userSettings.showMarkets.indexOf(args[0]) != -1){// if show all or market selected update market
//console.log("ticker event " + args[0]);
		var row = $("#marketRow" + args[0]);
		row.find('.price').html(args[1]);
		row.find('.lowestAsk').html(args[2]);
		row.find('.highestBid').html(args[3]);
		row.find('.change').html(exactRound(args[4] * 100,2));
		if(args[4] < 0){ row.find('.change').addClass('neg'); }else{ row.find('.change').removeClass('neg'); }
		row.find('.volume').html(parseFloat(args[5]).toFixed(0));
		//row.find('.price').html(d[pair]['quoteVolume']);
		//row.find('.isFrozen').html(args[7]);
		row.find('.high24hr').html(args[8]);
		row.find('.low24hr').html(args[9]);
		
		if(lastTickerData[args[0]].last != args[1]){
			let priceChange = lastTickerData[args[0]].last > args[1] ? 'priceChangeDown' : 'priceChangeUp';
			row.addClass(priceChange); // flash a price change color
			setTimeout(function(){
				row.removeClass(priceChange);
			}, 600);
			
		}
	}
	
	lastTickerData[args[0]] = {
        last: args[1],
        lowestAsk: args[2],
        highestBid: args[3],
        percentChange: args[4],
        baseVolume: args[5],
        quoteVolume: args[6],
        //isFrozen: args[7],
        high24hr: args[8],
        low24hr: args[9]
    };

	
	
	if(userSettings.showMarkets.indexOf(args[0]) != -1){// update hilights
//console.log("update hilights " + JSON.stringify(lastTickerData[args[0]]) );
		let pair = args[0];
		let split = pair.split("_");
		var ch =  exactRound(lastTickerData[args[0]].percentChange * 100,2);
		var chPosNeg = '';
		if (ch < 0) { chPosNeg = 'neg';}
		if (ch >= 0) {
			ch = String('+') + ch;
		}
		$('#' + pair + 'Chart .hilights .lastPrice .info').html(lastTickerData[args[0]].last);
		$('#' + pair + 'Chart .hilights .change .info').html(ch);
		$('#' + pair + 'Chart .hilights .change .info').removeClass('neg').addClass(chPosNeg);
		$('#' + pair + 'Chart .hilights .high .info').html(lastTickerData[args[0]].high24hr);
		$('#' + pair + 'Chart .hilights .low .info').html(lastTickerData[args[0]].low24hr);
		$('#' + pair + 'Chart .hilights .volume .name1').html(split[0]);
		$('#' + pair + 'Chart .hilights .volume .name2').html(split[1]);
		$('#' + pair + 'Chart .hilights .volume .info .vol1').html(lastTickerData[args[0]].baseVolume);
		$('#' + pair + 'Chart .hilights .volume .info .vol2').html(lastTickerData[args[0]].quoteVolume);
	}
	
}


function showHideMarketsChange(){
	userSettings.showHide = document.getElementById("showHideCb").checked;
	showHideMarkets();
}

function showHideMarkets(){
	$('#marketsTab > tbody  > tr').each(function() {
		let pair = $(this).data("pair");
		if(userSettings.showHide && userSettings.showMarkets.indexOf(pair) == -1){
			$(this).addClass("hideMarketRow");
		}else{
			$(this).removeClass("hideMarketRow");
		}
	});
}

function initPage(){
	//chartEndDate = Math.floor(Date.now()/1000);// - serverTimeDeff;
	chartEndDate = Math.floor(new Date().getTime() / 1000);
	chartStartDate = chartEndDate - chartRange;
	
	smaPeriod = userSettings.smaPeriod;
	emaPeriod = userSettings.emaPeriod;
	ema2Period = userSettings.ema2Period;
	showSma = userSettings.showSma;
	showEma = userSettings.showEma;
	showFib = userSettings.showFib;
	bollingerBand = userSettings.bollingerBand;
	showEma2 = userSettings.showEma2;
	
	$("#emaCheckbox").prop('checked', userSettings.showEma);
    $("#ema2Checkbox").prop('checked', userSettings.showEma2);
    $("#smaCheckbox").prop('checked', userSettings.showSma);
    $("#fibCheckbox").prop('checked', userSettings.showFib);
    $("#bollingerCheckbox").prop('checked', userSettings.bollingerBand);
    $("#smaPeriod").val(smaPeriod);
    $("#emaPeriod").val(emaPeriod);
    $("#ema2Period").val(ema2Period);
	
	// mute Alert
	$("#muteAlert").prop('checked', userSettings.muteAlert);
	
	// set show hide markets by user setting
	$("#showHideCb").prop('checked', userSettings.showHide);
	showHideMarkets();
	
	/*/ populate input text with user settings vol alert, bollinger alert
	$('#marketsTab > tbody > tr input:text').each(function() {
		$(this).val(userSettings.marketAlerts[$(this).data("pair")][$(this).data("type")]);
	});*/
	
	// toggle alert info hide/show
	$("#alertsTog").click(function(){
		$("#alertsInfo").toggle(100, function(){
			if($("#alertsTog").html() == "+"){
				$("#alertsTog").html("-");
			}else{
				$("#alertsTog").html("+");
			}
		});
	});
	
	// check user selected markets
	$('#marketsTab input:checkbox').each(function() {
		$(this).prop('checked', userSettings.showMarkets.indexOf($(this).data("pair")) != -1);
	});
	
	// on change update user alerts settings 
	$('body').on('change', '.alerts input:text', function() {
		userSettings.marketAlerts[$(this).data("pair")][$(this).data("type")] = $(this).val();
	});
	// on change bollinger alert selection
	$('body').on('change', '.alerts input:checkbox', function() {
		userSettings.marketAlerts[$(this).data("pair")][$(this).data("type")] = $(this).is(':checked');
	});
	
	// user changed market selection. update user setting.
	$('#marketsTab input:checkbox').change(function() {
		let pair = $(this).val();
        if(this.checked) {// user selected new market. display big chart
			insertChart(pair);
            userSettings.showMarkets.push(pair);
			weightedAverageArr[pair] = [];
			initCandleSticks(pair);
        }else{
			let index = userSettings.showMarkets.indexOf(pair);
			userSettings.showMarkets.splice(index, 1);
			if ('connection' in window){
				window.connection.send(JSON.stringify({command: "unsubscribe", channel: pair}));
			}
			let index2 = marketSubscription.indexOf(pair);
			marketSubscription.splice(index2, 1);
			delete allChartData[pair];
			delete weightedAverageArr[pair];
			removeChart(pair);
		}
    });
	// sort markets table
	$('#marketsTab th').click(function(){
		var table = $(this).parents('table').eq(0);
		//var rows = table.find('tr:gt(0)').toArray().sort(comparer($(this).index()));
		var rows = table.find('tbody tr').toArray().sort(comparer($(this).index()));
		this.asc = !this.asc;
		if (!this.asc){rows = rows.reverse();}
		for (var i = 0; i < rows.length; i++){table.append(rows[i]);}
	});
	// big chart controlls
		$('.group.zoom button').click(function(){
		var id = $(this).attr('id');
		chartRange = id.substr(4, id.length) * 3600;
		chartEndDate = Math.floor(new Date().getTime() / 1000);
		chartStartDate = chartEndDate - chartRange;
		$(this).parent().parent().find('.chartButtonActive').removeClass('chartButtonActive');
		$(this).addClass('chartButtonActive');

		initAllChars();
//		saveExchangeSettings();
	});
	$('.group.candlesticks button').click(function(){
		var id = $(this).attr('id');
		chartType = id.substr(11, id.length);
		$(this).parent().parent().find('.chartButtonActive').removeClass('chartButtonActive');
		$(this).addClass('chartButtonActive');
		initAllChars();
//		saveExchangeSettings();
	});
	// clear Alert click
	$('body').on('click', '.clearAlert', function(){
		$(this).closest('div').remove();
	});
	
	// init Chart Tool Panel
    $("#emaCheckbox").change(function () {
        if ($("#emaCheckbox:checked").length > 0) {
            showEma = true;
			userSettings.showEma = true;
        } else {
            showEma = false;
			userSettings.showEma = false;
        }
        initAllChars();
    });

    $("#ema2Checkbox").change(function () {
        if ($("#ema2Checkbox:checked").length > 0) {
            showEma2 = true;
			userSettings.showEma2 = true;
        } else {
            showEma2 = false;
			userSettings.showEma2 = false;
        }
        initAllChars();
    });

    $("#smaCheckbox").change(function () {
        if ($("#smaCheckbox:checked").length > 0) {
            showSma = true;
			userSettings.showSma = true;
        } else {
            showSma = false;
			userSettings.showSma = false;
        }
        initAllChars();
    });

    $("#fibCheckbox").change(function () {
        if ($("#fibCheckbox:checked").length > 0) {
            showFib = true;
			userSettings.showFib = true;
        } else {
            showFib = false;
			userSettings.showFib = false;
        }
        initAllChars();
    });

    $("#bollingerCheckbox").change(function () {
        if ($("#bollingerCheckbox:checked").length > 0) {
            bollingerBand = true;
			userSettings.bollingerBand = true;
        } else {
            bollingerBand = false;
			userSettings.bollingerBand = false;
        }
        initAllChars();
    });

    $("#smaPeriod").on("keyup", function () {
        smaPeriod = document.getElementById("smaPeriod").value;
		userSettings.smaPeriod = smaPeriod;
        initAllChars();
    });

    $("#emaPeriod").on("keyup", function () {
        emaPeriod = document.getElementById("emaPeriod").value;
		userSettings.emaPeriod = emaPeriod;
        initAllChars();
    });

    $("#ema2Period").on("keyup", function () {
        ema2Period = document.getElementById("ema2Period").value;
		userSettings.ema2Period = ema2Period;
        initAllChars();
    });
	
	// Main Chart mouse down. draw Fibonacci
	$('#chartWrapper').on('mousedown', '.chart30Canvas', function (e) {
		if(userFib.canvasId != null){// restore chart image without Fibonacci.
			let c = document.getElementById(userFib.canvasId);
			let ctx = c.getContext("2d");
			ctx.putImageData(chartImgData,0,0);
			userFib = {canvasId:null, startX:null, startY:null, endX:null, endY:null, mouse:null};
			return;
		}
		userFib.canvasId = $(this).attr('id');
		userFib.startX = e.pageX - this.offsetLeft - $(this).offset().left;
		userFib.startY = e.pageY - this.offsetTop - $(this).offset().top;
		userFib.mouse = "down";
//console.log(userFib.canvasId + " - " + userFib.startX + " " + userFib.startY);
		let c = document.getElementById(userFib.canvasId);
		let ctx = c.getContext("2d");
		chartImgData = ctx.getImageData(0,0,c.width,c.height);// save chart image without Fibonacci
	});
	
	// Main Chart mouse up. draw Fibonacci
	$('#chartWrapper').on('mouseup', '.chart30Canvas', function (e) {
		if(userFib.canvasId == null){
			return;
		}
		userFib.mouse = "up";
//console.log(userFib.endX + " " + userFib.endY);
	});
	
	// Main Chart mouse over
    $('#chartWrapper').on('mousemove', '.canvasContainer', function (e) {
	    let posX = e.pageX - this.offsetLeft - $(".canvasContainer").offset().left;
		for(pair in allChartData){
			let chartRangeTop = allChartData[pair].returnArray.rangeTop;
			let chartRangeBottom = allChartData[pair].returnArray.rangeBottom;
			let mainChartHeight = allChartData[pair].returnArray.mainChartHeight;
			let chartDecimals = allChartData[pair].returnArray.decimals;
			let indicatorHeight = allChartData[pair].returnArray.indicatorHeight;
			let macdRange = allChartData[pair].returnArray.macdRange;
			let split = pair.split("_");
			let primaryCurrency = split[0];
			let secondaryCurrency = split[1];
			for (var c = 0; c < allChartData[pair]['returnArray'].detectArray.length; c++) {
				var info = allChartData[pair]['returnArray'].detectArray[c];
				var gap = info.right - info.left;
				if (posX > info.left && posX < info.right) {
					crosshairH = info.left + (gap/3) - 0.5;
					var volumeString = info.volume.toString();
					if (volumeString.length > 6)volumeString = volumeString.substring(0, 6);
					var quoteVolumeString = info.quoteVolume.toString();
					if (quoteVolumeString.length > 8 && quoteVolumeString.indexOf(".")>0){
						var qSub = quoteVolumeString.substring(0, quoteVolumeString.indexOf("."));
						if (qSub.length>4){
							quoteVolumeString = qSub;
						} else {
							quoteVolumeString = quoteVolumeString.substring(0,8);
						}
					}

					var chartInfoString = "<table class='mainChartInfoTable'><tr><td class='description'>Open:</td><td>" + info.open.toFixed(8) + "</td><td>&nbsp;</td>"
						+ "<td class='description'>Close:</td><td>" + info.close.toFixed(8) + "</td><td>&nbsp;</td>"
						+ "<td class='description'>High:</td><td>" + info.high.toFixed(8) + "</td><td>&nbsp;</td>"
						+ "<td class='description'>Low:</td><td>" + info.low.toFixed(8) + "</td></tr>"
						+ "<tr><td class='description'>Wtd Avg:</td><td>" + info.weightedAverage.toFixed(8) + "</td><td>&nbsp;</td>"
						+ "<td class='description'>" + "Vol (" + primaryCurrency + "):</td><td>" + volumeString + "</td><td>&nbsp;</td>"
						+ "<td class='description'>" + "Vol (" + secondaryCurrency + "):</td><td>" + quoteVolumeString + "</td><td>&nbsp;</td>"
						+ "<td class='description'>Date:</td><td>" + info.date + "</td></tr></table>";
					var indicatorString = "<table class='indicatorInfoTable'><tr><td class='description'>MACD:</td><td>" + info.macd.toFixed(8) + "</td>"
						+ "<td class='description'>Sig:</td><td>" + info.sig.toFixed(8) + "</td>"
						+ "<td class='description'>Hist:</td><td>" + info.hist.toFixed(8) + "</td></tr></table>";
					$("#" + pair + "Chart #mainChartInfo").empty().append(chartInfoString);
					$("#" + pair + "Chart #indicatorInfo").empty().append(indicatorString);
					break;
				}
			}
			
			if (typeof crosshairH == "undefined")
				crosshairH = allChartData[pair]['candleStick'][allChartData[pair]['candleStick'].length-1].left + (gap/3) - 0.5;
			
			l = e.pageX - 160;
			crosshairV = e.pageY - $("#" + pair + "canvasContainer").offset().top - 3;
			
			if (crosshairV<=mainChartHeight){
				linePosText = (chartRangeTop - ((crosshairV+1)/mainChartHeight)*(chartRangeTop-chartRangeBottom)).toFixed(chartDecimals);
			} else {
				linePosText = (0-((crosshairV - mainChartHeight) / indicatorHeight * (macdRange * 2) - macdRange)).toFixed(8);
			}
			
			$("#" + pair + "Chart #crosshairHInfoTextContainer").empty().append(linePosText);
			crosshairHInfoPos = crosshairV;
			if (crosshairV < 12 | (crosshairV>mainChartHeight && crosshairV<mainChartHeight + 12)){
				$("#" + pair + "Chart #crosshairHInfo").css('margin-top','0px');
			} else {
				$("#" + pair + "Chart #crosshairHInfo").css('margin-top','-' + $('#crosshairHInfo').css('height'));
			}

			$("#" + pair + "Chart #mainChartInfo").css('display', 'block');
			$("#" + pair + "Chart #indicatorInfo").css('top', mainChartHeight+1).css('display', 'block');
			$("#" + pair + "Chart #chartCrosshairV").css('left', crosshairH).css('display', 'block');
			if (crosshairV > (mainChartHeight + indicatorHeight) | crosshairV<-1){
				$("#" + pair + "Chart #crosshairHInfo").css('top', crosshairHInfoPos).css('display', 'none');
				$("#" + pair + "Chart #chartCrosshairH").css('top', crosshairV).css('display', 'none');
			} else {
				$("#" + pair + "Chart #crosshairHInfo").css('top', crosshairHInfoPos).css('display', 'block');
				$("#" + pair + "Chart #chartCrosshairH").css('top', crosshairV).css('display', 'block');
			}
		}
		
		// check if user draw Fibonacci
		if(userFib.mouse == "down"){
			userFib.endX = posX;
			userFib.endY = e.pageY - this.offsetTop - $(this).offset().top;
//console.log(userFib.canvasId + " - " +userFib.endX + " " + userFib.endY);
			drawFibonnaci();
		}
    });
    //$('.canvasContainer').mouseout(function() { 
	$('#chartWrapper').on('mouseout', '.canvasContainer', function (e) {
        $(".mainChartInfo").css('display', 'none');
        $(".indicatorInfo").css('display', 'none');
        $(".crosshairHInfo").css('display', 'none');
        $(".chartCrosshairH").css('display', 'none');
        $(".chartCrosshairV").css('display', 'none');
    });
}

function drawFibonnaci(){
	let c = document.getElementById(userFib.canvasId);
	let ctx = c.getContext("2d");
	ctx.putImageData(chartImgData,0,0);// restore chart image without Fibonacci.
	let scaleFactor = window.devicePixelRatio;
	let fibLineColor = "rgba(175,100,100,0.75)";
	ctx.lineWidth = 1 * scaleFactor;
	let marginLeft = userFib.startX;//65 * scaleFactor;
	let height = c.height;
	//let width = c.width;
	let marginBottom = height - userFib.startY;//60;
	let top = 0.01504;//0;
	let bottom = 0.0143;//1000000;
	let chartHigh = top;
	let chartLow = bottom;
	
	let marginTop = userFib.endY * scaleFactor;//30 * scaleFactor;
	let vScale = (height - (marginTop + marginBottom)) / (top - bottom);
	let shft = Math.floor(bottom * vScale - marginBottom);
	ctx.fillStyle = fibLineColor;
	let fibPrice;
	x = marginLeft;
	w = c.width - x - 60;
	h = 1;
	fibPrice = chartLow;
	y = Math.floor(height - (fibPrice * vScale));
	ctx.fillRect(x, y + shft, w, h);
	ctx.fillText("0%", x, y + shft - 1);
	fibPrice = chartLow + ((chartHigh - chartLow) * 0.236);
	y = Math.floor(height - (fibPrice * vScale));
	ctx.fillRect(x, y + shft, w, h);
	ctx.fillText("23.6%", x, y + shft - 1);
	fibPrice = chartLow + ((chartHigh - chartLow) * 0.382);
	y = Math.floor(height - (fibPrice * vScale));
	ctx.fillRect(x, y + shft, w, h);
	ctx.fillText("38.2%", x, y + shft - 1);
	fibPrice = chartLow + ((chartHigh - chartLow) * 0.5);
	y = Math.floor(height - (fibPrice * vScale));
	ctx.fillRect(x, y + shft, w, h);
	ctx.fillText("50%", x, y + shft - 1);
	fibPrice = chartLow + ((chartHigh - chartLow) * 0.618);
	y = Math.floor(height - (fibPrice * vScale));
	ctx.fillRect(x, y + shft, w, h);
	ctx.fillText("61.8%", x, y + shft - 1);
	fibPrice = chartHigh;
	y = Math.floor(height - (fibPrice * vScale));
	ctx.fillRect(x, y + shft, w, h);
	ctx.fillText("100%", x, y + shft - 1);
	ctx.beginPath();
	//ctx.moveTo(fibLowX + marginLeft, height - chartLow * vScale + shft);
	//ctx.lineTo(fibHighX + marginLeft, height - chartHigh * vScale + shft);
	ctx.moveTo(userFib.startX, userFib.startY);
	ctx.lineTo(userFib.endX, userFib.endY);
	ctx.strokeStyle = fibLineColor;
	ctx.stroke();
}

function comparer(index) {
    return function(a, b) {
        var valA = getCellValue(a, index);
		var valB = getCellValue(b, index);
        return parseFloat(valA) == valA ? parseFloat(valA) - parseFloat(valB) : valA.localeCompare(valB);
    }
}

function getCellValue(row, index){ return $(row).children('td').eq(index).text() }

function exactRound(num, decimals) {
	if (decimals<0)decimals=0;
    var sign = num >= 0 ? 1 : -1;
    return (Math.round((num * Math.pow(10, decimals)) + (sign * 0.001)) / Math.pow(10, decimals)).toFixed(decimals);
}

function insertChart(pair){
	if(document.getElementById(pair + "Chart") != null){
		return;
	}

	let cw = $('#chartWrapper').width();
//console.log(cw);
	weightedAverageArr[pair] = [];
	let split = pair.split("_");
	var ch =  exactRound(lastTickerData[pair].percentChange * 100,2);
	var chPosNeg = '';
	if (ch < 0) { chPosNeg = 'neg';}
	if (ch >= 0) { ch = String('+') + ch; }
	let secondaryCurrency = split[1];
	var html = '<div id="' + pair + 'Chart" class="wrapper"><div class="mainHeading"><div class="chartTitle"><div class="full">' + currencyNamesArray[secondaryCurrency] + '</div><div class="code">' + pair.replace("_", "/") + '</div></div>'
	+ '<div id="' + pair + 'alerts" class="alerts"><div><label for="' + pair + '-volumeAlert">Volume Alert: </label><input type="text" id="' + pair + '-volumeAlert" data-type="volume" data-pair="' + pair + '" value="' + userSettings.marketAlerts[pair].volume + '" /></div><div><label for="' + pair + '-bollingerAlert">Bollinger Alert:&nbsp;</label><input type="checkbox" data-type="bollinger" id="' + pair + '-bollingerAlert" data-pair="' + pair + '"' + (userSettings.marketAlerts[pair].bollinger == true ? " checked": "") + '></div></div>'
	+ '<div id="hilights" class="hilights"><div class="rowHilights"><div class="lastPrice"><div class="name">Last Price</div><div class="info">' + lastTickerData[pair].last + '</div></div><div class="change"><div class="name">24hr Change</div><div class="info" class="' + chPosNeg + '">' + ch + '</div></div><div class="high"><div class="name">24hr High</div><div class="info">' + lastTickerData[pair].high24hr + '</div></div><div class="low"><div class="name">24hr Low</div><div class="info">' + lastTickerData[pair].low24hr + '</div></div></div><div class="rowHilights"><div class="volume"><div class="name">24hr Volume:</div><div class="info"><span class="vol1">' + lastTickerData[pair].baseVolume + '</span> <span class="name name1">' + split[0] + '</span> /  <span class="vol2">' + lastTickerData[pair].quoteVolume + '</span> <span class="name name2">' + split[0] + '</span></div></div></div></div></div>'
	+ '<div class="bigChart"><div class="chart"><div id="' + pair + 'currentChartRange" class="currentChartRange"><div class="high label">High:</div><div class="high info"></div><div class="low label">Low:</div><div class="low info"></div></div>'
	+ '<div id="' + pair + 'chartLoading"><p><i class="fa fa-refresh fa-spin"></i> Loading chart...</p></div><div id="' + pair + 'canvasContainer" class="canvasContainer">'
	+ '<canvas id="' + pair + 'chart30Canvas" width="' + cw + '" class="chart30Canvas" style="width: ' + cw + 'px; height: 450px;" height="450"></canvas>'
	+ '<div id="mainChartInfo" class="mainChartInfo" style="display: none;"><table class="mainChartInfoTable"><tbody><tr><td class="description">Open:</td><td>0.00005635</td><td>&nbsp;</td><td class="description">Close:</td><td>0.00005670</td><td>&nbsp;</td><td class="description">High:</td><td>0.00005679</td><td>&nbsp;</td><td class="description">Low:</td><td>0.00005635</td></tr><tr><td class="description">Wtd Avg:</td><td>0.00005663</td><td>&nbsp;</td><td class="description">Vol (BTC):</td><td>1.0288</td><td>&nbsp;</td><td class="description">Vol (STR):</td><td>18167</td><td>&nbsp;</td><td class="description">Date:</td><td>Jan 27  04:35</td></tr></tbody></table></div>'
	+ '<div id="crosshairHInfo" style="margin-top: -12px; top: 357px; display: none;" class="crosshairHInfo"><div id="crosshairHInfoTextContainer">0.00000085</div></div>'
	+ '<div id="chartCrosshairH" class="chartCrosshairH" style="top: 357px; display: none;"></div>'
	+ '<div id="chartCrosshairV" class="chartCrosshairV" style="left: 2043.47px; display: none;"></div>'
	+ '<div id="indicatorInfo" style="top: 333px; display: none;" class="indicatorInfo"><table class="indicatorInfoTable"><tbody><tr><td class="description">MACD:</td><td>0.00000005</td><td class="description">Sig:</td><td>-0.00000003</td><td class="description">Hist:</td><td>0.00000008</td></tr></tbody></table></div>'
	+ '</div></div></div></div>'
	$("#chartWrapper").append(html);
}

function removeChart(pair){
	$("#" + pair + "Chart").remove();
}

function initAllChars(){ // big chart
	for(let x=0;x<userSettings.showMarkets.length;x++){
		let pair = userSettings.showMarkets[x];
		insertChart(pair);
		setTimeout(function(){initCandleSticks(pair);}, x * 500);
	}
}

function initCandleSticks(pair){
	//let url = 'https://poloniex.com/public?command=returnChartData&currencyPair=' + pair + '&start=0&end=9999999999&period=' + chartType;
	let sd = chartStartDate - (chartStartDate % chartType) - (chartType * 30);
	let url = 'https://poloniex.com/public?command=returnChartData&currencyPair=' + pair + '&start=' + sd + '&end=9999999999&period=' + chartType;
//console.log(url);
	$.get(url).done(function(chartData){
//console.log(chartData);
		allChartData[pair] = {};
		allChartData[pair]['candleStick'] = chartData;
		$('#' + pair + 'chartLoading').remove();//hideChartLoading();
		refreshChart(pair);
		
		if(marketSubscription.indexOf(pair) == -1){// init order book subscription
			marketSubscription.push(pair);
			window.connection.send(JSON.stringify({command: "subscribe",channel: pair}));
		}
	});
}

function refreshAllChart(){
	for(let x=0;x<userSettings.showMarkets.length;x++){
		let pair = userSettings.showMarkets[x];
		refreshChart(pair);
//console.log(pair);
	}
}
	
function refreshChart(pair){
	let sd = allChartData[pair]['candleStick'][30]['date'];
	let fd = allChartData[pair]['candleStick'][0]['date'];
	let ed = allChartData[pair]['candleStick'][allChartData[pair]['candleStick'].length-1]['date'];
	let tr = ed - fd;
	chartLeftPercent = (sd-fd) / tr;

	returnArray = candlestick(pair, allChartData[pair]['candleStick'], chartLeftPercent, 1.0, chartType, dark, smaPeriod, emaPeriod, ema2Period, showSma, showEma, showEma2, showFib, bollingerBand);
	high = parseFloat(returnArray['high']);
	low = parseFloat(returnArray['low']);
	if (isNaN(high))high = 0;
	if (isNaN(low))low = 0;
	$('#' + pair + 'currentChartRange .low.info').empty().append(low.toFixed(8));
    $('#' + pair + 'currentChartRange .high.info').empty().append(high.toFixed(8));
	
	allChartData[pair]['returnArray'] = returnArray;
}

function getChartWidth(){
	var cw = $('#chartWrapper .chart').css('width');
	cw = Number(cw.substr(0, cw.length-2)-2); // -2 to account for 1px border
	return cw;
}

function printAlert(msg){
	let dobj = document.getElementById("alertsInfo");
	let d = new Date();
	dobj.innerHTML = '<div>' + d.toLocaleString() + " - " + msg + '<span class="clearAlert">X</span></div>' + dobj.innerHTML;
}

function clearAllAlerts(){
	if(confirm("Clear All Alerts?")){
		document.getElementById("alertsInfo").innerHTML = "";
	}
}

function muteAlert(){
	userSettings.muteAlert = document.getElementById("muteAlert").checked;
}

function resizeCharts() {
	let chartWidth = $('.canvasContainer').width();
console.log("resizeCharts: " + chartWidth);    
    //$('.chart30Canvass').css({width: chartWidth + "px"});
	$('.chart30Canvas').each(function(){
		$(this).width(chartWidth);
		$(this).prop('width', chartWidth);
	});
	$('#alertsWrapper').width(chartWidth);
	refreshAllChart();
}

$(document).ready(function() {
	initPage();
	getTickerInfo();
});

$(window).unload(function() { localStorage.setItem("userSettings", JSON.stringify(userSettings)) });// save User Settings
$(window).resize(function(){resizeCharts();});

function candlestick(pair, data, left, right, chartType, dark, smaPeriod,
    emaPeriod, ema2Period, showSma, showEma, showEma2, showFib,
    bollingerBand,mobile) {
    if (data === undefined) { return false;}
    if (mobile === undefined)mobile = false;
    if (smaPeriod < 1) smaPeriod = 1;
    if (emaPeriod < 1) emaPeriod = 1;
    if (ema2Period < 1) ema2Period = 1;
	let canvasId = pair + "chart30Canvas";
    var c = document.getElementById(canvasId);
    var ctx = c.getContext("2d");
    var scaleFactor = window.devicePixelRatio;
    // scaleFactor = 1;

    if (scaleFactor > 1) {
        if (c.style.width < 10) {
            c.style.width = c.width;
            c.style.height = c.height;
            c.width = c.width * scaleFactor;
            c.height = c.height * scaleFactor;
            var ctx = c.getContext("2d");
        }
    }
    ctx.clearRect(0, 0, c.width, c.height);

    var alignYaxisRight = true;
    // console.log('candlestick, data = ', data);

    var width = c.width;
    var height = c.height;
    ctx.lineWidth = 1 * scaleFactor;
    var marginLeft = 65 * scaleFactor;
    var marginRight = 0;
    if (alignYaxisRight) {
        marginLeft = 0 * scaleFactor;
        marginRight = 60 * scaleFactor;
        width = width - marginRight;
    } 
    
	var dateMargin = (mobile ? 10 : 12) * scaleFactor;
    var marginBottom = mobile ? 40 : 60;
    var paddingBottom = mobile ? 22 : 40;
    var marginTop = (mobile ? 10 : 30) * scaleFactor;
    
    var indicatorMargin = mobile ? 0.0 : Math.floor((height - marginBottom) * 0.20); // indicatorMargin already has scale applied from height
    
    marginBottom *= scaleFactor;
    paddingBottom *= scaleFactor;
    paddingBottom += indicatorMargin;
    marginBottom += indicatorMargin;
    
    var smooth = 2 / (1 + parseInt(emaPeriod));
    var smooth2 = 2 / (1 + parseInt(ema2Period));
    var macdSmooth = 2 / (1 + 9);
    var ema12Smooth = 2 / (1 + 12);
    var ema26Smooth = 2 / (1 + 26);
    
    var prevEmaEntry = 0;
    var prevMacdEntry = 0;
    var prevEma12Entry = 0;
    var prevEma26Entry = 0;
    
    var macdEntry = 0;
    var ema12Entry = 0;
    var ema26Entry = 0;
    var high, low, open, close, volume;
    var chartHigh, chartLow;
    var top = 0,
        bottom = 1000000,
        maxVol = 0;
    var x, y, w, h, vScale, volScale, count = 0;
    var fibLowX, fibHighX;
    //trace(canvasId + ' w = ' + width + ', h = ' + height + ' ; d=' +dark);
    if (dark) {
        var borderColor = "#1f3232";
        var wickColor = "#274141";
        var textColor = "#6f9397";
        var hLineColor = "#1f3232";
        var vLineColor = "#1f3232";
        var volumeColor = "#172a2c";
        var greenColor = "#117e1a";
        var redColor = "#7b1111";
        var emaColor = "rgb(190,190,30)";
        var ema2Color = "rgb(150,110,70)";
        var smaColor = "rgba(70,120,230,0.7)";
        var fibLineColor = "rgba(197,132,7,0.3)";
    } else {
        var borderColor = "#91abac";
        var wickColor = "#223535";
        var textColor = "#1e2324";
        var hLineColor =  "#e9f0f0";
        var vLineColor = "#e9f0f0";
        var volumeColor = "#b5c8c9";
        var greenColor = "#339349";
        var redColor = "#a42015";
        var emaColor = "rgb(210,200,130)";
        var ema2Color = "rgb(200,150,230)";
        var smaColor = "rgba(30,60,190,0.7)";
        var fibLineColor = "rgba(175,100,100,0.75)";
    }

    if (right > 1) right = 1;
    if (left >= right)left = right - 0.001;
    if (left < 0) left = 0;
    if (right <= left)right = left + 0.001;
    
    numberOfCandles = Math.floor(data.length * (right - left));
	//numberOfCandles = data.length;
    var end = Math.floor(data.length * right);
	//var end = data.length;
    var start = end - numberOfCandles;
//console.log("start: " + start + " - end: " + end);
    var candleWidth = ((width - marginLeft) / numberOfCandles) * (2 / 3);
    var wickWidth = candleWidth / 4;
    var candleSpacing = candleWidth / 2;
    var returnArray = new Array();
    var detectArray = new Array();
    var month = new Array();
    var bBand1 = [];
    var bBand2 = [];
    var sd;
    month[0] = "Jan";
    month[1] = "Feb";
    month[2] = "Mar";
    month[3] = "Apr";
    month[4] = "May";
    month[5] = "Jun";
    month[6] = "Jul";
    month[7] = "Aug";
    month[8] = "Sep";
    month[9] = "Oct";
    month[10] = "Nov";
    month[11] = "Dec";
    var size = Math.floor(10 * scaleFactor);
    ctx.font = size + "px Arial";
    ctx.clearRect(0, 0, width, height);
    if (data.length < 2) {
        ctx.fillStyle = textColor;
        ctx.fillText(
            "Chart will be available once a few more trades have been made.",
            width / 2 - 245, height / 2 - 20);
        detectArray[0] = {
            'left': 0,
            'right': width * scaleFactor,
            'high': 0.0,
            'low': 0.0,
            'open': 0.0,
            'close': 0.0,
            'volume': 0.0,
            'quoteVolume': 0.0,
            'weightedAverage': 0.0,
            'date': 'N/A'
        };
        returnArray['detectArray'] = detectArray;
        returnArray['high'] = 0.0;
        returnArray['low'] = 0.0;
        return returnArray;
    }
    for (var i = start; i < end; i++) {
        if (i < 0) continue;
        if (!(data[i] instanceof Object)) {
            delete data[i];
            continue;
        }
        if (data[i].high > top) top = data[i].high;
        if (data[i].low < bottom) bottom = data[i].low;
        if (data[i].volume > maxVol) maxVol = data[i].volume;
    }
    chartHigh = top;
    chartLow = bottom;
    if (top == bottom) {
        top += 0.00000005;
        bottom -= 0.00000005;
        if (bottom < 0) bottom = 0;
    }
    vScale = (height - (marginTop + marginBottom)) / (top - bottom);
    volScale = (height - marginTop) / maxVol;
    volScale = volScale * 0.6;
    shft = Math.floor(bottom * vScale - marginBottom);
    var step = Math.floor(height / (50*scaleFactor));
    var decimals = 4;
    var counter = 1;
    while (bottom.toFixed(counter) == 0 && decimals < 8) {
        decimals++;
        counter++;
    }
    var sticksPerTimestamp = Math.round(32*scaleFactor/candleWidth);
    if (sticksPerTimestamp < 1) sticksPerTimestamp = 1;
    var dateString, timeString;
    var timestampCount = sticksPerTimestamp;

    // Draw vertical lines and dates
    for (var i = start; i < end; i++) {
        if (i < 0) continue;
        if (!(data[i] instanceof Object)) {
            delete data[i];
            continue;
        }
        if (timestampCount == sticksPerTimestamp) {
            timestampCount = 0;
            var date = new Date(data[i].date * 1000);
            dateString = month[date.getUTCMonth()] + " " + date.getUTCDate();
            timeString = " " + ("0" + date.getUTCHours()).slice(-2) + ":" +
                ("0" + date.getUTCMinutes()).slice(-2);
            ctx.fillStyle = vLineColor;
            x = marginLeft + count * (candleWidth + candleSpacing) + (
                candleWidth / 2);
            y = 0;
            w = 1;
            h = height;
            ctx.fillRect(x, y, w, h);
            ctx.fillStyle = textColor;

            var dateH =  height - dateMargin;
            var timeH = dateH + 10*scaleFactor;
            x -= 13 * scaleFactor;

            if (alignYaxisRight) {
                if (count > 0) {
                    ctx.fillText(dateString, x, dateH);
                    ctx.fillText(timeString, x, timeH);
                }
            } else {
                // align y axis left
                
                ctx.fillText(dateString, x, dateH);
                
                ctx.fillText(timeString, x, timeH);
            }
                
        }
        timestampCount++;
        count++;
    }
    
    if (alignYaxisRight) { 
        // draw rightmost v line
        ctx.fillStyle = borderColor;
        ctx.moveTo(0, width);
        ctx.fillRect(width, 0, 1, height);
    }

    count = 0;
    var lineBottom = bottom - ((marginBottom - paddingBottom) / vScale);
    if (lineBottom < 0){
	    lineBottom = 0;
	    paddingBottom -= Math.round((bottom - ((marginBottom - paddingBottom) / vScale)) * vScale);
    }
    var lineTop = top + (marginTop / vScale);
    // horiz lines and yaxis text
    for (var l = lineBottom; l <= lineTop+((lineTop - lineBottom) / step)/2; l += (lineTop - lineBottom) / step) {
        ctx.fillStyle = hLineColor;
        x = marginLeft;
        y = Math.floor(height - (l * vScale));
        w = width;
        h = 1;
        var horizLineW = width; 
        if (alignYaxisRight) { horizLineW = c.width; }
        ctx.fillRect(x, y + shft, horizLineW, h);
        ctx.fillStyle = textColor;
        // move yaxis text into right margin
        var labelPos = 0;
        if (alignYaxisRight) { labelPos = w + 5; }
        var txtYpos = y + shft - 3;
        if ((l+(lineTop - lineBottom)/step)>lineTop+((lineTop - lineBottom) / step)/2)txtYpos+=10*scaleFactor+(2/scaleFactor);
        ctx.fillText(l.toFixed(decimals), labelPos, txtYpos);
        lineRangeTop = l;
    }
    lineRangeBottom = lineBottom;
    
    for (var i = 0; i < start; i++) {
        if (!(data[i] instanceof Object)) {
            delete data[i];
            continue;
        }
        close = data[i].close;

        if (prevEmaEntry == 0) prevEmaEntry = close;
        emaEntry = (close * smooth) + (prevEmaEntry * (1 - smooth));
        prevEmaEntry = emaEntry;
        
        if (prevEma12Entry == 0)prevEma12Entry = close;
        ema12Entry = (close * ema12Smooth) + (prevEma12Entry * (1 - ema12Smooth));
        prevEma12Entry = ema12Entry;
        
         if (prevEma26Entry == 0)prevEma26Entry = close;
        ema26Entry = (close * ema26Smooth) + (prevEma26Entry * (1 - ema26Smooth));
        prevEma26Entry = ema26Entry;
        
        macdClose = prevEma12Entry-prevEma26Entry;
        if (prevMacdEntry == 0)prevMacdEntry = macdClose;
        macdEntry = (macdClose * macdSmooth) + (prevMacdEntry * (1 - macdSmooth));
        prevMacdEntry = macdEntry;
    }
    
    ctx.beginPath();
    ctx.moveTo(marginLeft, height - (prevEmaEntry * vScale) + shft);
    for (var i = start; i < end; i++) {
        if (i < 0) continue;
        if (!(data[i] instanceof Object)) {
            delete data[i];
            continue;
        }
        high = data[i].high;
        low = data[i].low;
        open = data[i].open;
        close = data[i].close;
        volume = data[i].volume;
        ctx.fillStyle = volumeColor;
        x = (count * candleWidth) + (count * candleSpacing) - 1;
        w = candleWidth + (candleSpacing / 2);
        h = Math.floor(volume * volScale);
        y = height - h;
        ctx.fillRect(x + marginLeft, y - paddingBottom, w, h);
        ctx.fillStyle = wickColor;
        x = (count * candleWidth) + (count * candleSpacing) + (candleWidth /
            2) - (wickWidth / 2);
        y = height - (high * vScale);
        h = (high - low) * vScale;
        //x=Math.floor(x);
        ctx.fillRect(x + marginLeft, y + shft, wickWidth, h);
        if (low == chartLow) fibLowX = x;
        if (high == chartHigh) fibHighX = x;
        if (close > open) {
            y = height - (close * vScale);
            h = (close - open) * vScale;
            ctx.fillStyle = greenColor;
        }
        if (close < open) {
            y = height - (open * vScale);
            h = (open - close) * vScale;
            ctx.fillStyle = redColor;
        }
        if (close == open) {
            y = height - (open * vScale);
            h = 1;
        }
        x = (count * candleWidth) + (count * candleSpacing);
        if (h < 1) h = 1;
        y = Math.floor(y);
        h = Math.floor(h);
        ctx.fillRect(x + marginLeft, y + shft, candleWidth, h);
        if (prevEmaEntry == 0){
	        prevEmaEntry = close;
	        ctx.moveTo(marginLeft, height - (prevEmaEntry * vScale) + shft);
	    }
        emaEntry = (close * smooth) + (prevEmaEntry * (1 - smooth));
        prevEmaEntry = emaEntry;
        ctx.lineTo(x + marginLeft + (candleWidth / 2), height - (emaEntry *
            vScale) + shft);
        var date = new Date(data[i].date * 1000);
        timeString = " " + ("0" + date.getUTCHours()).slice(-2) + ":" + (
            "0" + date.getUTCMinutes()).slice(-2);
        dateString = month[date.getUTCMonth()] + " " + date.getUTCDate() +
            " " + timeString;
        detectArray[count] = {
            'left': (x + marginLeft) / scaleFactor,
            'right': (x + marginLeft + candleWidth + candleSpacing) / scaleFactor,
            'high': high,
            'low': low,
            'open': open,
            'close': close,
            'volume': volume,
            'quoteVolume': data[i].quoteVolume,
            'weightedAverage': data[i].weightedAverage,
            'date': dateString
        };
        count++;
        // because the canvas is 2x as wide as the div that contains it, for hi-res screens, we have to scale down the detect array elements
        // count += scaleFactor / 2;
    }
    // trace('create detectArray (' + detectArray.length + '), ' + detectArray[detectArray.length-1].right);
    // trace('scale is ' + scaleFactor);
    ctx.strokeStyle = emaColor;
    if (showEma) ctx.stroke();
    var iiStart = start - smaPeriod;
    var smaCount = 0;
    var sma = 0;
    if (iiStart < 0) iiStart = 0;
    for (var ii = iiStart; ii < start; ii++) {
        sma += data[ii].close
        smaCount++;
    }
    sma = sma / smaCount;
    bBand1.push(sma - (sd * 2));
    bBand2.push(sma + (sd * 2));
    ctx.beginPath();
    ctx.moveTo(marginLeft, height - (sma * vScale) + shft);
    count = 0;
    for (var i = start; i < end; i++) {
        iiStart = i - smaPeriod;
        smaCount = 0;
        sma = 0;
        if (iiStart < 0) iiStart = 0;
        for (var ii = iiStart; ii <= i; ii++) {
            sma += data[ii].close
            smaCount++;
        }
        sma = sma / smaCount;
        x = (count * candleWidth) + (count * candleSpacing);
        ctx.lineTo(x + marginLeft + (candleWidth / 2), height - (sma *
            vScale) + shft);
        //if (bollingerBand) {
            // Standard Deviation
            sd = 0;
            for (var ii = iiStart; ii <= i; ii++) {
                sd += (data[ii].close - sma) * (data[ii].close - sma);
            }
            sd = Math.sqrt(sd / smaCount);
            bBand1.push(sma - (sd * 2));
            bBand2.push(sma + (sd * 2));
        //}
        count++;
    }
    ctx.strokeStyle = smaColor;
    if (showSma) ctx.stroke();
    if (bollingerBand) {
        ctx.beginPath();
        ctx.moveTo(marginLeft, height - (bBand1[0] * vScale) + shft);
        count = 0;
        for (var i = 1; i < bBand1.length; i++) {
            x = (count * candleWidth) + (count * candleSpacing);
            ctx.lineTo(x + marginLeft + (candleWidth / 2), height - (bBand1[
                i] * vScale) + shft);
            count++;
        }
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(marginLeft, height - (bBand2[0] * vScale) + shft);
        count = 0;
        for (var i = 1; i < bBand2.length; i++) {
            x = (count * candleWidth) + (count * candleSpacing);
            ctx.lineTo(x + marginLeft + (candleWidth / 2), height - (bBand2[
                i] * vScale) + shft);
            count++;
        }
        ctx.stroke();
    }
	
	// check bollinger Alert
	if(userSettings.marketAlerts[pair].bollinger && catchBolAlert){
		catchBolAlert = false;
//console.log("bollinger low: " + bBand1[bBand1.length-1]);
		if(bBand1[bBand1.length-1] >= data[data.length-1].low){
			printAlert('<a href="#' + pair + 'Chart">' + pair + "</a> Bollinger Low");
			if(!userSettings.muteAlert){
				audio2.play();
			}
		}
//console.log("bollinger high: " + bBand2[bBand2.length-1]);
		if(bBand2[bBand2.length-1] <= data[data.length-1].high){
			printAlert('<a href="#' + pair + 'Chart">' + pair + "</a> Bollinger High");
			if(!userSettings.muteAlert){
				audio2.play();
			}
		}
	}
	
    // Ema2
    if (showEma2) {
        prevEmaEntry = 0;
        for (var i = 0; i < start; i++) {
            close = data[i].close;
            if (prevEmaEntry == 0) prevEmaEntry = close;
            emaEntry = (close * smooth2) + (prevEmaEntry * (1 - smooth2));
            prevEmaEntry = emaEntry;
        }
        ctx.beginPath();
        ctx.moveTo(marginLeft, height - (prevEmaEntry * vScale) + shft);
        count = 0;
        for (var i = start; i < end; i++) {
            if (!(data[i] instanceof Object)) {
                delete data[i];
                continue;
            }
            close = data[i].close;
            if (prevEmaEntry == 0){
	            prevEmaEntry = close;
	            ctx.moveTo(marginLeft, height - (prevEmaEntry * vScale) + shft);
	        }
            x = (count * candleWidth) + (count * candleSpacing);
            emaEntry = (close * smooth2) + (prevEmaEntry * (1 - smooth2));
            prevEmaEntry = emaEntry;
            ctx.lineTo(x + marginLeft + (candleWidth / 2), height - (
                emaEntry * vScale) + shft);
            count++;
        }
        ctx.strokeStyle = ema2Color;
        ctx.stroke();
    }
    
    // MACD
    if (mobile){
	    ctx.beginPath();
	    ctx.moveTo(marginLeft, height - paddingBottom);
	    ctx.lineTo(c.width, height - paddingBottom);
	    ctx.strokeStyle = textColor;
	    ctx.stroke();
    } else {
	    var macdData = [];
	    var macdRange = 0;
	    var startMacd = prevEma12Entry - prevEma26Entry;
	    var startSig = prevMacdEntry;
	    count = 0;
	    
		for (var i = start; i < end; i++){
			close = data[i].close;
			
			if (prevEma12Entry==0)prevEma12Entry = close;
			ema12Entry = (close * ema12Smooth) + (prevEma12Entry * (1 - ema12Smooth));
            prevEma12Entry = ema12Entry;
            
            if (prevEma26Entry==0)prevEma26Entry = close;
            ema26Entry = (close * ema26Smooth) + (prevEma26Entry * (1 - ema26Smooth));
            prevEma26Entry = ema26Entry;
            
            macdClose = ema12Entry - ema26Entry;
            if (prevMacdEntry==0)prevMacdEntry = macdClose;
            macdEntry = (macdClose * macdSmooth) + (prevMacdEntry * (1 - macdSmooth));
            prevMacdEntry = macdEntry;
			
			hist = macdClose-macdEntry;
            macdData[i] = { "macd": macdClose,
	            			"sig": macdEntry,
	            			"hist": hist};
	        
	        detectArray[count].macd = macdClose;
	        detectArray[count].sig = macdEntry;
	        detectArray[count].hist = hist;
	        count++;
	        macdRange = Math.max(macdRange,Math.abs(macdClose),Math.abs(macdEntry));    			
   		}
   		macdRange *= 1.1; // Padding
   		if (macdRange==0)macdRange=1;
   		
		var ivScale = indicatorMargin / (macdRange*2);
		mShft = (paddingBottom - indicatorMargin) + (macdRange*ivScale);
				
	    for (l=(0-macdRange);l<=macdRange;l=l+((macdRange*scaleFactor)/(2*scaleFactor))){
		    ctx.beginPath();
		    ctx.moveTo(marginLeft, height - (l * ivScale) - mShft);
		    ctx.lineTo(c.width, height - (l * ivScale) - mShft);
		    ctx.strokeStyle = hLineColor;
		    if (l==(0-macdRange) | l==(macdRange))ctx.strokeStyle = textColor;
		    ctx.stroke();
		    
		    ctx.fillStyle = textColor;
	        labelPos = width + 5;
	        var txtYpos = height - (l * ivScale) - mShft - 3
	        if (l>0)txtYpos += 10*scaleFactor+(2/scaleFactor);
	        if (l != 0)ctx.fillText(l.toFixed(8), labelPos, txtYpos);
	    }
	    
	    // MACD and Historgram
	    ctx.beginPath();
        ctx.moveTo(marginLeft, height - (startMacd * ivScale) - mShft);
        count = 0;
        for (var i = start; i < end; i++){
	        x = (count * candleWidth) + (count * candleSpacing);
            ctx.lineTo(x + marginLeft + (candleWidth / 2), height - (macdData[i]['macd'] * ivScale) - mShft);
            
            x = (count * candleWidth) + (count * candleSpacing);
            ctx.fillStyle = macdData[i]['hist']>0 ? greenColor : redColor;
            tinyShift = macdData[i]['hist']>0 ? 1 : -1;
            ctx.fillRect(x + marginLeft,height-mShft,candleWidth,0-(macdData[i]['hist'] * ivScale));
            count++;
        }
        ctx.strokeStyle = emaColor;
        ctx.stroke();
        
        // Signal Line
	    ctx.beginPath();
        ctx.moveTo(marginLeft, height - (startSig * ivScale) - mShft);
        count = 0;
        for (var i = start; i < end; i++){
	        x = (count * candleWidth) + (count * candleSpacing);
            ctx.lineTo(x + marginLeft + (candleWidth / 2), height - (macdData[i]['sig'] * ivScale) - mShft);
            count++;
        }
        ctx.strokeStyle = ema2Color;
        ctx.stroke();
    }
    // Fibonacci Retracement
    if (showFib) {
        ctx.fillStyle = fibLineColor;
        var fibPrice;
        x = marginLeft;
        w = width;
        h = 1;
        fibPrice = chartLow;
        y = Math.floor(height - (fibPrice * vScale));
        ctx.fillRect(x, y + shft, w, h);
        ctx.fillText("0%", x, y + shft - 1);
        fibPrice = chartLow + ((chartHigh - chartLow) * 0.236);
        y = Math.floor(height - (fibPrice * vScale));
        ctx.fillRect(x, y + shft, w, h);
        ctx.fillText("23.6%", x, y + shft - 1);
        fibPrice = chartLow + ((chartHigh - chartLow) * 0.382);
        y = Math.floor(height - (fibPrice * vScale));
        ctx.fillRect(x, y + shft, w, h);
        ctx.fillText("38.2%", x, y + shft - 1);
        fibPrice = chartLow + ((chartHigh - chartLow) * 0.5);
        y = Math.floor(height - (fibPrice * vScale));
        ctx.fillRect(x, y + shft, w, h);
        ctx.fillText("50%", x, y + shft - 1);
        fibPrice = chartLow + ((chartHigh - chartLow) * 0.618);
        y = Math.floor(height - (fibPrice * vScale));
        ctx.fillRect(x, y + shft, w, h);
        ctx.fillText("61.8%", x, y + shft - 1);
        fibPrice = chartHigh;
        y = Math.floor(height - (fibPrice * vScale));
        ctx.fillRect(x, y + shft, w, h);
        ctx.fillText("100%", x, y + shft - 1);
        ctx.beginPath();
        ctx.moveTo(fibLowX + marginLeft, height - chartLow * vScale + shft);
        ctx.lineTo(fibHighX + marginLeft, height - chartHigh * vScale +
            shft);
        ctx.strokeStyle = fibLineColor;
        ctx.stroke();
    }
	
	// if user fib save new image data
	if(userFib.canvasId != null && userFib.canvasId.indexOf(pair) != -1){
		let c = document.getElementById(userFib.canvasId);
		let ctx = c.getContext("2d");
		chartImgData = ctx.getImageData(0,0,c.width,c.height);
		drawFibonnaci();
	}
	
    returnArray['detectArray'] = detectArray;
    returnArray['high'] = chartHigh;
    returnArray['low'] = chartLow;
    returnArray['rangeTop'] = typeof lineRangeTop == "undefined" ? 0 : lineRangeTop;
    returnArray['rangeBottom'] = typeof lineRangeBottom == "undefined" ? 0 : lineRangeBottom;
    returnArray['decimals'] = decimals;
    returnArray['mainChartHeight'] = (height - paddingBottom)/scaleFactor;
    returnArray['indicatorHeight'] = indicatorMargin/scaleFactor;
    returnArray['macdRange'] = macdRange;
    return returnArray;
}